<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kurupey Magic - Fail Safe</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui-layer { position: absolute; top: 20px; left: 20px; color: white; z-index: 100; pointer-events: none; }
        #status-bar { color: #00ffcc; font-family: monospace; background: rgba(0,0,0,0.5); padding: 5px; }
        
        /* The Camera View */
        #debug-box { 
            position: absolute; bottom: 20px; right: 20px; 
            width: 320px; height: 240px; 
            border: 2px solid #00ffcc; border-radius: 8px; 
            overflow: hidden; z-index: 200;
            background: #111;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #sketch_canvas { 
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100%; 
            transform: scaleX(-1); /* Mirror to match video */
        }
        
        #btn-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 300; }
        button { padding: 20px 50px; font-size: 1.5rem; cursor: pointer; background: #00ffcc; border: none; border-radius: 50px; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>Kurupey Cosmic Engine</h1>
    <div id="status-bar">STATUS: SYSTEM READY</div>
    <p>1. Click Start | 2. Allow Camera | 3. Show Hand</p>
</div>

<div id="btn-container">
    <button id="startBtn">START MAGIC</button>
</div>

<div id="debug-box">
    <video id="input_video" playsinline></video>
    <canvas id="sketch_canvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const status = document.getElementById('status-bar');
    const PARTICLE_COUNT = 8000;
    let mode = 'scatter';

    // --- 1. THREE.JS SCENE ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    camera.position.z = 40;

    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const tar = new Float32Array(PARTICLE_COUNT * 3);
    const col = new Float32Array(PARTICLE_COUNT * 3);

    for(let i=0; i<PARTICLE_COUNT; i++) {
        tar[i*3] = (Math.random()-0.5)*100;
        tar[i*3+1] = (Math.random()-0.5)*80;
        tar[i*3+2] = (Math.random()-0.5)*40;
        col[i*3]=0.4; col[i*3+1]=0.4; col[i*3+2]=1; 
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
    const points = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 0.25, vertexColors: true, blending: THREE.AdditiveBlending }));
    scene.add(points);

    // --- 2. SHAPE LOGIC ---
    function updateTargets(shape) {
        if(shape === 'sphere') {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                tar[i*3] = 15 * Math.cos(theta) * Math.sin(phi);
                tar[i*3+1] = 15 * Math.sin(theta) * Math.sin(phi);
                tar[i*3+2] = 15 * Math.cos(phi);
                col[i*3]=0; col[i*3+1]=1; col[i*3+2]=0.5;
            }
        } else if (shape === 'star') {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const angle = (i / PARTICLE_COUNT) * (Math.PI * 2);
                const r = (i % 2 === 0) ? 22 : 8;
                const sa = Math.floor(i / (PARTICLE_COUNT/10)) * (Math.PI/5);
                tar[i*3] = Math.cos(sa - Math.PI/2) * r;
                tar[i*3+1] = Math.sin(sa - Math.PI/2) * r;
                tar[i*3+2] = 0;
                col[i*3]=1; col[i*3+1]=0.8; col[i*3+2]=0;
            }
        } else if (shape === 'scatter') {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                tar[i*3] = (Math.random()-0.5)*80;
                tar[i*3+1] = (Math.random()-0.5)*60;
                tar[i*3+2] = (Math.random()-0.5)*40;
                col[i*3]=0.4; col[i*3+1]=0.4; col[i*3+2]=1;
            }
        }
    }

    // --- 3. MEDIAPIPE TRACKING ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('sketch_canvas');
    const canvasCtx = canvasElement.getContext('2d');

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

    hands.onResults((results) => {
        // Clear and resize canvas
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            status.innerText = "STATUS: HAND TRACKED";
            const landmarks = results.multiHandLandmarks[0];
            
            // Draw skeleton
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FFCC', lineWidth: 5});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0055', lineWidth: 2});

            // Gesture Logic
            const up = [8, 12, 16, 20].filter(id => landmarks[id].y < landmarks[id-2].y).length;
            const isFist = landmarks[8].y > landmarks[5].y && landmarks[12].y > landmarks[9].y;

            if (isFist) { if(mode!='sphere'){ mode='sphere'; updateTargets('sphere'); } }
            else if (up === 3) { if(mode!='star'){ mode='star'; updateTargets('star'); } }
            else if (up >= 1) { /* Placeholder for text modes */ }
            else { if(mode!='scatter'){ mode='scatter'; updateTargets('scatter'); } }
        } else {
            status.innerText = "STATUS: SEARCHING FOR HAND...";
        }
        canvasCtx.restore();
    });

    // --- 4. STARTUP ---
    document.getElementById('startBtn').addEventListener('click', () => {
        status.innerText = "STATUS: INITIALIZING CAMERA...";
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start().then(() => {
            status.innerText = "STATUS: CAMERA ACTIVE";
            document.getElementById('btn-container').style.display = 'none';
        }).catch(err => {
            status.innerText = "ERROR: CAMERA BLOCKED";
        });
    });

    // --- 5. ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        const pArr = geometry.attributes.position.array;
        const cArr = geometry.attributes.color.array;

        for(let i=0; i<PARTICLE_COUNT*3; i++) {
            // Apply drift to scatter mode
            let drift = (mode === 'scatter') ? (Math.random()-0.5)*0.1 : 0;
            pArr[i] += (tar[i] - pArr[i]) * 0.1 + drift;
            cArr[i] += (col[i] - cArr[i]) * 0.1;
        }
        
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        
        if(mode === 'sphere' || mode === 'star') points.rotation.y += 0.01;
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>

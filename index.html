<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kurupey Final Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; z-index: 10; pointer-events: none; }
        #controls { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 20; }
        button { padding: 20px 40px; cursor: pointer; background: #ff0055; color: white; border: none; border-radius: 10px; font-weight: bold; font-size: 1.5em; box-shadow: 0 0 30px rgba(255,0,85,0.4); }
        #status { color: #00ffcc; margin-top: 10px; font-size: 0.9em; text-transform: uppercase; }
    </style>
</head>
<body>

<div id="ui">
    <h1>Kurupey Cosmic</h1>
    <div id="status">Click Start to Initialize</div>
</div>

<div id="controls">
    <button id="startButton">START SYSTEM</button>
</div>

<video id="input_video" style="display:none" playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    const PARTICLE_COUNT = 10000;
    let mode = 'scatter'; 
    let pulse = 1.0;
    
    // --- Scene ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    camera.position.z = 50; // Pull camera back so things aren't too big

    // --- Particles ---
    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(PARTICLE_COUNT * 3);
    const tar = new Float32Array(PARTICLE_COUNT * 3);
    const col = new Float32Array(PARTICLE_COUNT * 3);
    const vels = new Float32Array(PARTICLE_COUNT);

    function resetToScatter() {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            tar[i*3] = (Math.random() - 0.5) * 80;
            tar[i*3+1] = (Math.random() - 0.5) * 60;
            tar[i*3+2] = (Math.random() - 0.5) * 40;
            col[i*3] = 0.5; col[i*3+1] = 0.5; col[i*3+2] = 1.0;
        }
    }
    resetToScatter();

    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
    const points = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 0.25, vertexColors: true, blending: THREE.AdditiveBlending }));
    scene.add(points);

    // --- Shapes ---
    function setSphere() {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            tar[i*3] = 20 * Math.cos(theta) * Math.sin(phi);
            tar[i*3+1] = 20 * Math.sin(theta) * Math.sin(phi);
            tar[i*3+2] = 20 * Math.cos(phi);
            col[i*3]=0; col[i*3+1]=1; col[i*3+2]=0.8;
        }
    }

    function setStar() {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const angle = (i / PARTICLE_COUNT) * (Math.PI * 2);
            const rot = -Math.PI / 2;
            const r = (i % 2 === 0) ? 25 : 10;
            // High-precision 5 point star
            const sa = Math.floor(i / (PARTICLE_COUNT/10)) * (Math.PI/5);
            tar[i*3] = Math.cos(sa + rot) * r;
            tar[i*3+1] = Math.sin(sa + rot) * r;
            tar[i*3+2] = (Math.random()-0.5)*5;
            col[i*3]=1; col[i*3+1]=0.9; col[i*3+2]=0;
        }
    }

    function setText(text1, text2, showEmoji) {
        const c = document.createElement('canvas');
        const x = c.getContext('2d');
        c.width = 1200; c.height = 400;
        x.fillStyle = 'white';
        x.font = 'bold 100px Arial';
        x.textAlign = 'center';
        x.fillText(text1, 600, 150);
        x.fillText(text2, 600, 280);
        if(showEmoji) x.fillText(":(", 1000, 215);

        const d = x.getImageData(0,0,1200,400).data;
        const pts = [];
        for(let row=0; row<400; row+=4) {
            for(let col=0; col<1200; col+=4) {
                if(d[(row*1200+col)*4] > 128) pts.push({x: (col-600)*0.1, y: (200-row)*0.1});
            }
        }
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const p = pts[i % pts.length];
            tar[i*3] = p.x; tar[i*3+1] = p.y; tar[i*3+2] = (Math.random()-0.5)*2;
            if(showEmoji) { col[i*3]=0.2; col[i*3+1]=0.6; col[i*3+2]=1; }
            else { col[i*3]=1; col[i*3+1]=0.1; col[i*3+2]=0.5; }
        }
    }

    // --- Tracking ---
    const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7 });

    hands.onResults((res) => {
        if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
            const lm = res.multiHandLandmarks[0];
            const up = [8, 12, 16, 20].filter(id => lm[id].y < lm[id-2].y).length;
            const isFist = lm[8].y > lm[5].y && lm[12].y > lm[9].y;

            if (isFist) { if(mode!=='sphere'){ mode='sphere'; setSphere(); } }
            else if (up === 2) { if(mode!=='love'){ mode='love'; setText("I LOVE YOU", "KURUPEY", false); } }
            else if (up === 3) { if(mode!=='star'){ mode='star'; setStar(); } }
            else if (up === 4) { if(mode!=='miss'){ mode='miss'; setText("MISS YOU", "PONAH", true); } }
            else { if(mode!=='scatter'){ mode='scatter'; resetToScatter(); } }
        }
    });

    // --- Loop ---
    function animate() {
        requestAnimationFrame(animate);
        const pArr = geometry.attributes.position.array;
        const cArr = geometry.attributes.color.array;
        
        const time = Date.now() * 0.005;
        const pFac = (mode === 'love' || mode === 'miss') ? 1.0 + Math.sin(time)*0.12 : 1.0;

        for(let i=0; i<PARTICLE_COUNT*3; i++) {
            pArr[i] += (tar[i] * pFac - pArr[i]) * 0.1;
            cArr[i] += (col[i] - cArr[i]) * 0.1;
        }
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        
        if(mode === 'sphere' || mode === 'star') points.rotation.y += 0.01;
        else points.rotation.y *= 0.9;

        renderer.render(scene, camera);
    }

    document.getElementById('startButton').onclick = () => {
        const cam = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 640, height: 480
        });
        cam.start();
        document.getElementById('controls').style.display = 'none';
        document.getElementById('status').innerText = "TRACKING ACTIVE";
    };

    animate();
    window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };
</script>
</body>
</html>

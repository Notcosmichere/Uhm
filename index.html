<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kurupey Centered Magic</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; z-index: 10; pointer-events: none; }
        #controls { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 20; }
        button { padding: 15px 35px; cursor: pointer; background: #00ffcc; color: #000; border: none; border-radius: 50px; font-weight: bold; font-size: 1.2em; }
        #status { color: #00ffcc; margin-top: 10px; font-size: 0.8em; letter-spacing: 2px; }
    </style>
</head>
<body>

<div id="ui">
    <h1>Kurupey Magic</h1>
    <div id="status">Waiting for Initialization...</div>
</div>

<div id="controls">
    <button id="startButton">START SYSTEM</button>
</div>

<video id="input_video" style="display:none" playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    const PARTICLE_COUNT = 8000;
    let mode = 'scatter'; 
    let pulseTime = 0;
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    camera.position.z = 30;

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targets = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const vels = new Float32Array(PARTICLE_COUNT); // Tears

    // Init particles
    for(let i=0; i<PARTICLE_COUNT; i++) {
        positions[i*3] = (Math.random() - 0.5) * 100;
        positions[i*3+1] = (Math.random() - 0.5) * 100;
        positions[i*3+2] = (Math.random() - 0.5) * 100;
        colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const points = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 0.12, vertexColors: true, blending: THREE.AdditiveBlending }));
    scene.add(points);

    // --- TEMPLATES ---
    function setSphere() {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            targets[i*3] = 12 * Math.cos(theta) * Math.sin(phi);
            targets[i*3+1] = 12 * Math.sin(theta) * Math.sin(phi);
            targets[i*3+2] = 12 * Math.cos(phi);
            colors[i*3]=0.1; colors[i*3+1]=0.9; colors[i*3+2]=0.6; // Teal Planet
        }
    }

    function setStar() {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const angle = (i / PARTICLE_COUNT) * (Math.PI * 2);
            const pointsCount = 5;
            const sharp = 0.5; // inner radius factor
            const r = (Math.abs((angle * pointsCount / Math.PI) % 2 - 1) * (1 - sharp) + sharp) * 15;
            targets[i*3] = Math.cos(angle - Math.PI/2) * r;
            targets[i*3+1] = Math.sin(angle - Math.PI/2) * r;
            targets[i*3+2] = (Math.random() - 0.5) * 5;
            colors[i*3]=1; colors[i*3+1]=0.8; colors[i*3+2]=0; // Gold
        }
    }

    function setText(t1, t2, isCrying) {
        const canv = document.createElement('canvas');
        const ctx = canv.getContext('2d');
        canv.width = 1200; canv.height = 400;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 80px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(t1, 500, 150);
        ctx.fillText(t2, 500, 250);
        
        if(isCrying) {
            ctx.font = '80px Arial';
            ctx.fillText(":(", 900, 200); // Emoji closer
        }

        const data = ctx.getImageData(0,0,1200,400).data;
        const pts = [];
        for(let y=0; y<400; y+=4) {
            for(let x=0; x<1200; x+=4) {
                if(data[(y*1200+x)*4] > 128) pts.push({x: (x-600)*0.06, y: (200-y)*0.06, isTear: (x > 850 && y > 200)});
            }
        }
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const p = pts[i % pts.length];
            targets[i*3] = p.x; targets[i*3+1] = p.y; targets[i*3+2] = (Math.random()-0.5)*2;
            vels[i] = p.isTear ? (Math.random()*0.1 + 0.05) : 0;
            if(isCrying) { colors[i*3]=0.4; colors[i*3+1]=0.6; colors[i*3+2]=1; }
            else { colors[i*3]=1; colors[i*3+1]=0.1; colors[i*3+2]=0.5; }
        }
    }

    // --- HANDS ---
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.8 });

    hands.onResults((res) => {
        if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
            const lm = res.multiHandLandmarks[0];
            const up = [8, 12, 16, 20].filter(id => lm[id].y < lm[id-2].y).length;
            const fist = lm[8].y > lm[5].y && lm[12].y > lm[9].y;

            if (fist) { if(mode!='sphere'){ mode='sphere'; setSphere(); } }
            else if (up === 2) { if(mode!='love'){ mode='love'; setText("I LOVE YOU", "KURUPEY", false); } }
            else if (up === 3) { if(mode!='star'){ mode='star'; setStar(); } }
            else if (up === 4) { if(mode!='miss'){ mode='miss'; setText("MISS YOU", "PONAH", true); } }
            else { mode = 'scatter'; for(let i=0; i<PARTICLE_COUNT*3; i++) { targets[i] = (Math.random()-0.5)*60; } }
        }
    });

    // --- ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        const pos = geometry.attributes.position.array;
        const col = geometry.attributes.color.array;
        pulseTime += 0.05;
        const pFac = (mode === 'love' || mode === 'miss') ? 1.0 + Math.sin(pulseTime)*0.1 : 1.0;

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i*3;
            if(mode === 'miss' && vels[i] > 0) {
                pos[i3+1] -= vels[i];
                if(pos[i3+1] < -10) pos[i3+1] = targets[i3+1];
            } else {
                pos[i3] += (targets[i3] * pFac - pos[i3]) * 0.1;
                pos[i3+1] += (targets[i3+1] * pFac - pos[i3+1]) * 0.1;
                pos[i3+2] += (targets[i3+2] - pos[i3+2]) * 0.1;
            }
            col[i3] += (colors[i3] - col[i3]) * 0.05;
            col[i3+1] += (colors[i3+1] - col[i3+1]) * 0.05;
            col[i3+2] += (colors[i3+2] - col[i3+2]) * 0.05;
        }
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        
        if(mode === 'sphere' || mode === 'star') points.rotation.y += 0.015;
        else points.rotation.y *= 0.9;

        renderer.render(scene, camera);
    }

    document.getElementById('startButton').addEventListener('click', () => {
        const cam = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 640, height: 480
        });
        cam.start();
        document.getElementById('controls').style.display = 'none';
        document.getElementById('status').innerText = "SYSTEM ACTIVE";
    });

    animate();
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
